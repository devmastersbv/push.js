{"version":3,"file":"push.min.js","sources":["../src/push/Messages.js","../src/push/Permission.js","../src/push/Util.js","../src/agents/AbstractAgent.js","../src/agents/DesktopAgent.js","../src/agents/MobileChromeAgent.js","../src/agents/MobileFirefoxAgent.js","../src/agents/MSAgent.js","../src/agents/WebKitAgent.js","../src/index.js","../src/push/Push.js"],"sourcesContent":["// @flow\nconst errorPrefix = 'PushError:';\n\nexport default {\n    errors: {\n        incompatible: `${errorPrefix} Push.js is incompatible with browser.`,\n        invalid_plugin: `${errorPrefix} plugin class missing from plugin manifest (invalid plugin). Please check the documentation.`,\n        invalid_title: `${errorPrefix} title of notification must be a string`,\n        permission_denied: `${errorPrefix} permission request declined`,\n        sw_notification_error: `${errorPrefix} could not show a ServiceWorker notification due to the following reason: `,\n        sw_registration_error: `${errorPrefix} could not register the ServiceWorker due to the following reason: `,\n        unknown_interface: `${errorPrefix} unable to create notification: unknown interface`\n    }\n};\n","// @flow\nimport type { Global } from 'types';\n\nexport default class Permission {\n    // Private members\n    _permissions: string[];\n    _win: Global;\n\n    // Public members\n    GRANTED: string;\n    DEFAULT: string;\n    DENIED: string;\n\n    constructor(win: Global) {\n        this._win = win;\n        this.GRANTED = 'granted';\n        this.DEFAULT = 'default';\n        this.DENIED = 'denied';\n        this._permissions = [this.GRANTED, this.DEFAULT, this.DENIED];\n    }\n\n    /**\n     * Requests permission for desktop notifications\n     * @param {Function} onGranted - Function to execute once permission is granted\n     * @param {Function} onDenied - Function to execute once permission is denied\n     * @return {void, Promise}\n     */\n    request(onGranted: () => void, onDenied: () => void) {\n        return arguments.length > 0\n            ? this._requestWithCallback(...arguments)\n            : this._requestAsPromise();\n    }\n\n    /**\n     * Old permissions implementation deprecated in favor of a promise based one\n     * @deprecated Since V1.0.4\n     * @param {Function} onGranted - Function to execute once permission is granted\n     * @param {Function} onDenied - Function to execute once permission is denied\n     * @return {void}\n     */\n    _requestWithCallback(onGranted: () => void, onDenied: () => void) {\n        const existing = this.get();\n\n        var resolve = (result = this._win.Notification.permission) => {\n            if (typeof result === 'undefined' && this._win.webkitNotifications)\n                result = this._win.webkitNotifications.checkPermission();\n            if (result === this.GRANTED || result === 0) {\n                if (onGranted) onGranted();\n            } else if (onDenied) onDenied();\n        };\n\n        /* Permissions already set */\n        if (existing !== this.DEFAULT) {\n            resolve(existing);\n        } else if (\n            this._win.webkitNotifications &&\n            this._win.webkitNotifications.checkPermission\n        ) {\n            /* Safari 6+, Legacy webkit browsers */\n            this._win.webkitNotifications.requestPermission(resolve);\n        } else if (\n            this._win.Notification &&\n            this._win.Notification.requestPermission\n        ) {\n            let promise = undefined;\n\n            let callback = () => {\n                if (promise) resolve();\n            };\n\n            promise = this._win.Notification.requestPermission(callback);\n\n            if (promise) {\n                promise.then(resolve).catch(function() {\n                    if (onDenied) onDenied();\n                });\n            }\n        } else if (onGranted) {\n            /* Let the user continue by default */\n            onGranted();\n        }\n    }\n\n    /**\n     * Requests permission for desktop notifications in a promise based way\n     * @return {Promise}\n     */\n    _requestAsPromise(): Promise<void> {\n        const existing = this.get();\n\n        let isGranted = result => result === this.GRANTED || result === 0;\n\n        /* Permissions already set */\n        var hasPermissions = existing !== this.DEFAULT;\n\n        /* Safari 6+, Chrome 23+ */\n        var isModernAPI =\n            this._win.Notification && this._win.Notification.requestPermission;\n\n        /* Legacy webkit browsers */\n        var isWebkitAPI =\n            this._win.webkitNotifications &&\n            this._win.webkitNotifications.checkPermission;\n\n        return new Promise((resolvePromise, rejectPromise) => {\n            var resolver = result =>\n                isGranted(result) ? resolvePromise() : rejectPromise();\n\n            if (hasPermissions) {\n                resolver(existing);\n            } else if (isWebkitAPI) {\n                this._win.webkitNotifications.requestPermission(result => {\n                    resolver(result);\n                });\n            } else if (isModernAPI) {\n                let promise = undefined;\n                let callback = () => {\n                    if (!promise) resolver(this._win.Notification.permission);\n                };\n\n                promise = this._win.Notification.requestPermission(callback);\n\n                /* Support for safari */\n                if (promise) {\n                    promise\n                        .then(result => {\n                            resolver(result);\n                        })\n                        .catch(rejectPromise);\n                }\n            } else resolvePromise();\n        });\n    }\n\n    /**\n     * Returns whether Push has been granted permission to run\n     * @return {Boolean}\n     */\n    has() {\n        return this.get() === this.GRANTED;\n    }\n\n    /**\n     * Gets the permission level\n     * @return {Permission} The permission level\n     */\n    get() {\n        let permission;\n\n        /* Safari 6+, Chrome 23+ */\n        if (this._win.Notification && this._win.Notification.permission)\n            permission = this._win.Notification.permission;\n        else if (\n            this._win.webkitNotifications &&\n            this._win.webkitNotifications.checkPermission\n        )\n            /* Legacy webkit browsers */\n            permission = this._permissions[\n                this._win.webkitNotifications.checkPermission()\n            ];\n        else if (navigator.mozNotification)\n            /* Firefox Mobile */\n            permission = this.GRANTED;\n        else if (this._win.external && this._win.external.msIsSiteMode)\n            /* IE9+ */\n            permission = this._win.external.msIsSiteMode()\n                ? this.GRANTED\n                : this.DEFAULT;\n        else permission = this.GRANTED;\n\n        return permission;\n    }\n}\n","// @flow\nexport default class Util {\n    static isUndefined(obj) {\n        return obj === undefined;\n    }\n\n    static isString(obj) {\n        return typeof obj === 'string';\n    }\n\n    static isFunction(obj) {\n        return obj && {}.toString.call(obj) === '[object Function]';\n    }\n\n    static isObject(obj) {\n        return typeof obj === 'object';\n    }\n\n    static objectMerge(target, source) {\n        for (var key in source) {\n            if (\n                target.hasOwnProperty(key) &&\n                this.isObject(target[key]) &&\n                this.isObject(source[key])\n            ) {\n                this.objectMerge(target[key], source[key]);\n            } else {\n                target[key] = source[key];\n            }\n        }\n    }\n}\n","// @flow\nimport type { Global } from 'types';\n\nexport default class AbstractAgent {\n    _win: Global;\n\n    constructor(win: Global) {\n        this._win = win;\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport { Util } from 'push';\nimport type { PushOptions, GenericNotification, Global } from 'types';\n\n/**\n * Notification agent for modern desktop browsers:\n * Safari 6+, Firefox 22+, Chrome 22+, Opera 25+\n */\nexport default class DesktopAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return this._win.Notification !== undefined;\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        return new this._win.Notification(title, {\n            icon:\n                Util.isString(options.icon) || Util.isUndefined(options.icon)\n                    ? options.icon\n                    : options.icon.x32,\n            body: options.body,\n            tag: options.tag,\n            requireInteraction: options.requireInteraction\n        });\n    }\n\n    /**\n     * Close a given notification\n     * @param notification - notification to close\n     */\n    close(notification: GenericNotification) {\n        notification.close();\n    }\n}\n","// @flow\nimport { Util, Messages } from 'push';\nimport { AbstractAgent } from 'agents';\nimport type { Global, GenericNotification, PushOptions } from 'types';\n\n/**\n * Notification agent for modern desktop browsers:\n * Safari 6+, Firefox 22+, Chrome 22+, Opera 25+\n */\nexport default class MobileChromeAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return (\n            this._win.navigator !== undefined &&\n            this._win.navigator.serviceWorker !== undefined\n        );\n    }\n\n    /**\n     * Returns the function body as a string\n     * @param func\n     */\n    getFunctionBody(func: () => void) {\n        const str = func.toString().match(/function[^{]+{([\\s\\S]*)}$/);\n        return typeof str !== 'undefined' && str !== null && str.length > 1\n            ? str[1]\n            : null;\n    }\n\n    /**\n     * Creates a new notification\n     * @param id                ID of notification\n     * @param title             Title of notification\n     * @param options           Options object\n     * @param serviceWorker     ServiceWorker path\n     * @param callback          Callback function\n     */\n    create(\n        id: number,\n        title: string,\n        options: PushOptions,\n        serviceWorker: string,\n        callback: (GenericNotification[]) => void\n    ) {\n        /* Register ServiceWorker */\n        this._win.navigator.serviceWorker.register(serviceWorker);\n\n        this._win.navigator.serviceWorker.ready\n            .then(registration => {\n                /* Local data the service worker will use */\n                let localData = {\n                    id: id,\n                    link: options.link,\n                    origin: document.location.href,\n                    onClick: Util.isFunction(options.onClick)\n                        ? this.getFunctionBody(options.onClick)\n                        : '',\n                    onClose: Util.isFunction(options.onClose)\n                        ? this.getFunctionBody(options.onClose)\n                        : ''\n                };\n\n                /* Merge the local data with user-provided data */\n                if (options.data !== undefined && options.data !== null)\n                    localData = Object.assign(localData, options.data);\n\n                /* Show the notification */\n                registration\n                    .showNotification(title, {\n                        icon: options.icon,\n                        body: options.body,\n                        vibrate: options.vibrate,\n                        tag: options.tag,\n                        data: localData,\n                        requireInteraction: options.requireInteraction,\n                        silent: options.silent\n                    })\n                    .then(() => {\n                        registration.getNotifications().then(notifications => {\n                            /* Send an empty message so the ServiceWorker knows who the client is */\n                            registration.active.postMessage('');\n\n                            /* Trigger callback */\n                            callback(notifications);\n                        });\n                    })\n                    .catch(function(error) {\n                        throw new Error(\n                            Messages.errors.sw_notification_error +\n                                error.message\n                        );\n                    });\n            })\n            .catch(function(error) {\n                throw new Error(\n                    Messages.errors.sw_registration_error + error.message\n                );\n            });\n    }\n\n    /**\n     * Close all notification\n     */\n    close() {\n        // Can't do this with service workers\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport type { Global, PushOptions } from 'types';\n\n/**\n * Notification agent for modern desktop browsers:\n * Safari 6+, Firefox 22+, Chrome 22+, Opera 25+\n */\nexport default class MobileFirefoxAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return this._win.navigator.mozNotification !== undefined;\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        let notification = this._win.navigator.mozNotification.createNotification(\n            title,\n            options.body,\n            options.icon\n        );\n\n        notification.show();\n\n        return notification;\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport { Util } from 'push';\nimport type { PushOptions, Global } from 'types';\n\n/**\n * Notification agent for IE9\n */\nexport default class MSAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return (\n            this._win.external !== undefined &&\n            this._win.external.msIsSiteMode !== undefined\n        );\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        /* Clear any previous notifications */\n        this._win.external.msSiteModeClearIconOverlay();\n\n        this._win.external.msSiteModeSetIconOverlay(\n            Util.isString(options.icon) || Util.isUndefined(options.icon)\n                ? options.icon\n                : options.icon.x16,\n            title\n        );\n\n        this._win.external.msSiteModeActivate();\n\n        return null;\n    }\n\n    /**\n     * Close a given notification\n     * @param notification - notification to close\n     */\n    close() {\n        this._win.external.msSiteModeClearIconOverlay();\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport type { Global, GenericNotification, PushOptions } from 'types';\n\n/**\n * Notification agent for old Chrome versions (and some) Firefox\n */\nexport default class WebKitAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return this._win.webkitNotifications !== undefined;\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        let notification = this._win.webkitNotifications.createNotification(\n            options.icon,\n            title,\n            options.body\n        );\n\n        notification.show();\n\n        return notification;\n    }\n\n    /**\n     * Close a given notification\n     * @param notification - notification to close\n     */\n    close(notification: GenericNotification) {\n        notification.cancel();\n    }\n}\n","// @flow\nimport { Push } from 'push';\n\nexport default new Push(typeof window !== 'undefined' ? window : global);\n","// @flow\nimport { Messages, Permission, Util } from 'push';\nimport type { PluginManifest, GenericNotification, PushOptions } from 'types';\n\n/* Import notification agents */\nimport {\n    DesktopAgent,\n    MobileChromeAgent,\n    MobileFirefoxAgent,\n    MSAgent,\n    WebKitAgent\n} from 'agents';\n\nexport default class Push {\n    // Private members\n    _agents: {\n        desktop: DesktopAgent,\n        chrome: MobileChromeAgent,\n        firefox: MobileFirefoxAgent,\n        ms: MSAgent,\n        webkit: WebKitAgent\n    };\n    _configuration: {\n        serviceWorker: string,\n        fallback: ({}) => void\n    };\n    _currentId: number;\n    _notifications: {};\n    _win: {};\n\n    // Public members\n    Permission: Permission;\n\n    constructor(win: {}) {\n        /* Private variables */\n\n        /* ID to use for new notifications */\n        this._currentId = 0;\n\n        /* Map of open notifications */\n        this._notifications = {};\n\n        /* Window object */\n        this._win = win;\n\n        /* Public variables */\n        this.Permission = new Permission(win);\n\n        /* Agents */\n        this._agents = {\n            desktop: new DesktopAgent(win),\n            chrome: new MobileChromeAgent(win),\n            firefox: new MobileFirefoxAgent(win),\n            ms: new MSAgent(win),\n            webkit: new WebKitAgent(win)\n        };\n\n        this._configuration = {\n            serviceWorker: '/serviceWorker.min.js',\n            fallback: function(payload) {}\n        };\n    }\n\n    /**\n     * Closes a notification\n     * @param id            ID of notification\n     * @returns {boolean}   denotes whether the operation was successful\n     * @private\n     */\n    _closeNotification(id: number | string) {\n        let success = true;\n        const notification = this._notifications[id];\n\n        if (notification !== undefined) {\n            success = this._removeNotification(id);\n\n            /* Safari 6+, Firefox 22+, Chrome 22+, Opera 25+ */\n            if (this._agents.desktop.isSupported())\n                this._agents.desktop.close(notification);\n            else if (this._agents.webkit.isSupported())\n                /* Legacy WebKit browsers */\n                this._agents.webkit.close(notification);\n            else if (this._agents.ms.isSupported())\n                /* IE9 */\n                this._agents.ms.close();\n            else {\n                success = false;\n                throw new Error(Messages.errors.unknown_interface);\n            }\n\n            return success;\n        }\n\n        return false;\n    }\n\n    /**\n   * Adds a notification to the global dictionary of notifications\n   * @param {Notification} notification\n   * @return {Integer} Dictionary key of the notification\n   * @private\n   */\n    _addNotification(notification: GenericNotification) {\n        const id = this._currentId;\n        this._notifications[id] = notification;\n        this._currentId++;\n        return id;\n    }\n\n    /**\n   * Removes a notification with the given ID\n   * @param  {Integer} id - Dictionary key/ID of the notification to remove\n   * @return {Boolean} boolean denoting success\n   * @private\n   */\n    _removeNotification(id: number | string) {\n        let success = false;\n\n        if (this._notifications.hasOwnProperty(id)) {\n            /* We're successful if we omit the given ID from the new array */\n            delete this._notifications[id];\n            success = true;\n        }\n\n        return success;\n    }\n\n    /**\n   * Creates the wrapper for a given notification\n   *\n   * @param {Integer} id - Dictionary key/ID of the notification\n   * @param {Map} options - Options used to create the notification\n   * @returns {Map} wrapper hashmap object\n   * @private\n   */\n    _prepareNotification(id: number, options: PushOptions) {\n        let wrapper;\n\n        /* Wrapper used to get/close notification later on */\n        wrapper = {\n            get: () => {\n                return this._notifications[id];\n            },\n\n            close: () => {\n                this._closeNotification(id);\n            }\n        };\n\n        /* Autoclose timeout */\n        if (options.timeout) {\n            setTimeout(() => {\n                wrapper.close();\n            }, options.timeout);\n        }\n\n        return wrapper;\n    }\n\n    /**\n   * Find the most recent notification from a ServiceWorker and add it to the global array\n   * @param notifications\n   * @private\n   */\n    _serviceWorkerCallback(\n        notifications: GenericNotification[],\n        options: PushOptions,\n        resolve: ({} | null) => void\n    ) {\n        let id = this._addNotification(notifications[notifications.length - 1]);\n\n        /* Listen for close requests from the ServiceWorker */\n        if (navigator && navigator.serviceWorker) {\n            navigator.serviceWorker.addEventListener('message', event => {\n                const data = JSON.parse(event.data);\n\n                if (data.action === 'close' && Number.isInteger(data.id))\n                    this._removeNotification(data.id);\n            });\n\n            resolve(this._prepareNotification(id, options));\n        }\n\n        resolve(null);\n    }\n\n    /**\n   * Callback function for the 'create' method\n   * @return {void}\n   * @private\n   */\n    _createCallback(\n        title: string,\n        options: PushOptions,\n        resolve: ({} | null) => void\n    ) {\n        let notification = null;\n        let onClose;\n\n        /* Set empty settings if none are specified */\n        options = options || {};\n\n        /* onClose event handler */\n        onClose = id => {\n            /* A bit redundant, but covers the cases when close() isn't explicitly called */\n            this._removeNotification(id);\n            if (Util.isFunction(options.onClose)) {\n                options.onClose.call(this, notification);\n            }\n        };\n\n        /* Safari 6+, Firefox 22+, Chrome 22+, Opera 25+ */\n        if (this._agents.desktop.isSupported()) {\n            try {\n                /* Create a notification using the API if possible */\n                notification = this._agents.desktop.create(title, options);\n            } catch (e) {\n                const id = this._currentId;\n                const sw = this.config().serviceWorker;\n                const cb = notifications =>\n                    this._serviceWorkerCallback(\n                        notifications,\n                        options,\n                        resolve\n                    );\n                /* Create a Chrome ServiceWorker notification if it isn't supported */\n                if (this._agents.chrome.isSupported()) {\n                    this._agents.chrome.create(id, title, options, sw, cb);\n                }\n            }\n            /* Legacy WebKit browsers */\n        } else if (this._agents.webkit.isSupported())\n            notification = this._agents.webkit.create(title, options);\n        else if (this._agents.firefox.isSupported())\n            /* Firefox Mobile */\n            this._agents.firefox.create(title, options);\n        else if (this._agents.ms.isSupported())\n            /* IE9 */\n            notification = this._agents.ms.create(title, options);\n        else {\n            /* Default fallback */\n            options.title = title;\n            this.config().fallback(options);\n        }\n\n        if (notification !== null) {\n            const id = this._addNotification(notification);\n            const wrapper = this._prepareNotification(id, options);\n\n            /* Notification callbacks */\n            if (Util.isFunction(options.onShow))\n                notification.addEventListener('show', options.onShow);\n\n            if (Util.isFunction(options.onError))\n                notification.addEventListener('error', options.onError);\n\n            if (Util.isFunction(options.onClick))\n                notification.addEventListener('click', options.onClick);\n\n            notification.addEventListener('close', () => {\n                onClose(id);\n            });\n\n            notification.addEventListener('cancel', () => {\n                onClose(id);\n            });\n\n            /* Return the wrapper so the user can call close() */\n            resolve(wrapper);\n        }\n\n        /* By default, pass an empty wrapper */\n        resolve(null);\n    }\n\n    /**\n   * Creates and displays a new notification\n   * @param {Array} options\n   * @return {Promise}\n   */\n    create(title: string, options: {}): Promise<void> {\n        let promiseCallback;\n\n        /* Fail if no or an invalid title is provided */\n        if (!Util.isString(title)) {\n            throw new Error(Messages.errors.invalid_title);\n        }\n\n        /* Request permission if it isn't granted */\n        if (!this.Permission.has()) {\n            promiseCallback = (resolve: () => void, reject: string => void) => {\n                this.Permission\n                    .request()\n                    .then(() => {\n                        this._createCallback(title, options, resolve);\n                    })\n                    .catch(() => {\n                        reject(Messages.errors.permission_denied);\n                    });\n            };\n        } else {\n            promiseCallback = (resolve: () => void, reject: string => void) => {\n                try {\n                    this._createCallback(title, options, resolve);\n                } catch (e) {\n                    reject(e);\n                }\n            };\n        }\n\n        return new Promise(promiseCallback);\n    }\n\n    /**\n   * Returns the notification count\n   * @return {Integer} The notification count\n   */\n    count() {\n        let count = 0;\n        let key;\n\n        for (key in this._notifications)\n            if (this._notifications.hasOwnProperty(key)) count++;\n\n        return count;\n    }\n\n    /**\n   * Closes a notification with the given tag\n   * @param {String} tag - Tag of the notification to close\n   * @return {Boolean} boolean denoting success\n   */\n    close(tag: string) {\n        let key, notification;\n\n        for (key in this._notifications) {\n            if (this._notifications.hasOwnProperty(key)) {\n                notification = this._notifications[key];\n\n                /* Run only if the tags match */\n                if (notification.tag === tag) {\n                    /* Call the notification's close() method */\n                    return this._closeNotification(key);\n                }\n            }\n        }\n    }\n\n    /**\n   * Clears all notifications\n   * @return {Boolean} boolean denoting whether the clear was successful in closing all notifications\n   */\n    clear() {\n        let key,\n            success = true;\n\n        for (key in this._notifications)\n            if (this._notifications.hasOwnProperty(key))\n                success = success && this._closeNotification(key);\n\n        return success;\n    }\n\n    /**\n   * Denotes whether Push is supported in the current browser\n   * @returns {boolean}\n   */\n    supported() {\n        let supported = false;\n\n        for (var agent in this._agents)\n            if (this._agents.hasOwnProperty(agent))\n                supported = supported || this._agents[agent].isSupported();\n\n        return supported;\n    }\n\n    /**\n   * Modifies settings or returns all settings if no parameter passed\n   * @param settings\n   */\n    config(settings?: {}) {\n        if (\n            typeof settings !== 'undefined' ||\n            (settings !== null && Util.isObject(settings))\n        )\n            Util.objectMerge(this._configuration, settings);\n\n        return this._configuration;\n    }\n\n    /**\n   * Copies the functions from a plugin to the main library\n   * @param plugin\n   */\n    extend(manifest: PluginManifest) {\n        var plugin,\n            Plugin,\n            hasProp = {}.hasOwnProperty;\n\n        if (!hasProp.call(manifest, 'plugin')) {\n            throw new Error(Messages.errors.invalid_plugin);\n        } else {\n            if (\n                hasProp.call(manifest, 'config') &&\n                Util.isObject(manifest.config) &&\n                manifest.config !== null\n            ) {\n                this.config(manifest.config);\n            }\n\n            Plugin = manifest.plugin;\n            plugin = new Plugin(this.config());\n\n            for (var member in plugin) {\n                if (\n                    hasProp.call(plugin, member) &&\n                    Util.isFunction(plugin[member])\n                )\n                    // $FlowFixMe\n                    this[member] = plugin[member];\n            }\n        }\n    }\n}\n"],"names":["Permission","win","_win","GRANTED","DEFAULT","DENIED","_permissions","this","onGranted","onDenied","arguments","length","_requestWithCallback","_requestAsPromise","existing","get","resolve","result","_this","Notification","permission","webkitNotifications","checkPermission","requestPermission","promise","undefined","then","catch","hasPermissions","isModernAPI","isWebkitAPI","Promise","resolvePromise","rejectPromise","resolver","_this2","isGranted","navigator","mozNotification","external","msIsSiteMode","Util","obj","toString","call","_typeof","target","source","key","hasOwnProperty","isObject","objectMerge","AbstractAgent","DesktopAgent","title","options","isString","icon","isUndefined","x32","body","tag","requireInteraction","notification","close","MobileChromeAgent","serviceWorker","func","str","match","id","callback","register","ready","localData","link","document","location","href","isFunction","onClick","getFunctionBody","onClose","data","Object","assign","showNotification","vibrate","silent","getNotifications","active","postMessage","notifications","error","Error","Messages","errors","sw_notification_error","message","sw_registration_error","MobileFirefoxAgent","createNotification","show","MSAgent","msSiteModeClearIconOverlay","msSiteModeSetIconOverlay","x16","msSiteModeActivate","WebKitAgent","cancel","_currentId","_notifications","_agents","_configuration","payload","success","_removeNotification","desktop","isSupported","webkit","ms","unknown_interface","wrapper","_closeNotification","timeout","_addNotification","addEventListener","JSON","parse","event","action","Number","isInteger","_prepareNotification","_this3","create","e","sw","config","chrome","_serviceWorkerCallback","firefox","fallback","onShow","onError","promiseCallback","invalid_title","has","reject","_createCallback","request","permission_denied","count","supported","agent","settings","manifest","plugin","hasProp","invalid_plugin","member","window","global"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gLACA,sCAAoB,gFAAA,qIAAA,oFAAA,6EAAA,2HAAA,gHAAA,wlCCECA,wBAULC,kBACHC,KAAOD,OACPE,QAAU,eACVC,QAAU,eACVC,OAAS,cACTC,cAAgBC,KAAKJ,QAASI,KAAKH,QAASG,KAAKF,kDASlDG,EAAuBC,UACpBC,UAAUC,OAAS,EACpBJ,KAAKK,gCAAwBF,WAC7BH,KAAKM,iEAUML,EAAuBC,cAClCK,EAAWP,KAAKQ,MAElBC,EAAU,eAACC,yDAASC,EAAKhB,KAAKiB,aAAaC,gBACrB,IAAXH,GAA0BC,EAAKhB,KAAKmB,sBAC3CJ,EAASC,EAAKhB,KAAKmB,oBAAoBC,mBACvCL,IAAWC,EAAKf,SAAsB,IAAXc,EACvBT,GAAWA,IACRC,GAAUA,QAIrBK,IAAaP,KAAKH,UACVU,QACL,GACHP,KAAKL,KAAKmB,qBACVd,KAAKL,KAAKmB,oBAAoBC,qBAGzBpB,KAAKmB,oBAAoBE,kBAAkBP,QAC7C,GACHT,KAAKL,KAAKiB,cACVZ,KAAKL,KAAKiB,aAAaI,kBACzB,KACMC,OAAUC,KAMJlB,KAAKL,KAAKiB,aAAaI,kBAJlB,WACPC,GAASR,UAMLU,KAAKV,GAASW,MAAM,WACpBlB,GAAUA,WAGfD,8DAWLM,EAAWP,KAAKQ,MAKlBa,EAAiBd,IAAaP,KAAKH,QAGnCyB,EACAtB,KAAKL,KAAKiB,cAAgBZ,KAAKL,KAAKiB,aAAaI,kBAGjDO,EACAvB,KAAKL,KAAKmB,qBACVd,KAAKL,KAAKmB,oBAAoBC,uBAE3B,IAAIS,QAAQ,SAACC,EAAgBC,OAC5BC,EAAW,mBAfH,mBAAUjB,IAAWkB,EAAKhC,SAAsB,IAAXc,EAgB7CmB,CAAUnB,GAAUe,IAAmBC,QAEvCL,IACSd,QACN,GAAIgB,IACF5B,KAAKmB,oBAAoBE,kBAAkB,cACnCN,UAEV,GAAIY,EAAa,KAChBL,OAAUC,KAKJU,EAAKjC,KAAKiB,aAAaI,kBAJlB,WACNC,GAASU,EAASC,EAAKjC,KAAKiB,aAAaC,kBAQzCM,KAAK,cACOT,KAEZU,MAAMM,QAEZD,2CASJzB,KAAKQ,QAAUR,KAAKJ,6CAWvBI,KAAKL,KAAKiB,cAAgBZ,KAAKL,KAAKiB,aAAaC,WACpCb,KAAKL,KAAKiB,aAAaC,WAEpCb,KAAKL,KAAKmB,qBACVd,KAAKL,KAAKmB,oBAAoBC,gBAGjBf,KAAKD,aACdC,KAAKL,KAAKmB,oBAAoBC,mBAE7Be,UAAUC,gBAEF/B,KAAKJ,QACbI,KAAKL,KAAKqC,UAAYhC,KAAKL,KAAKqC,SAASC,aAEjCjC,KAAKL,KAAKqC,SAASC,eAC1BjC,KAAKJ,QACLI,KAAKH,QACGG,KAAKJ,iBCvKVsC,uFACEC,eACAjB,IAARiB,mCAGKA,SACU,iBAARA,qCAGAA,UACPA,GAAiC,yBAAvBC,SAASC,KAAKF,oCAGnBA,SACU,WAAfG,EAAOH,uCAGCI,EAAQC,OAClB,IAAIC,KAAOD,EAERD,EAAOG,eAAeD,IACtBzC,KAAK2C,SAASJ,EAAOE,KACrBzC,KAAK2C,SAASH,EAAOC,SAEhBG,YAAYL,EAAOE,GAAMD,EAAOC,MAE9BA,GAAOD,EAAOC,YCxBhBI,EAGjB,WAAYnD,kBACHC,KAAOD,GCECoD,6HAAqBD,wDAQA3B,IAA3BlB,KAAKL,KAAKiB,4CASdmC,EAAeC,UACX,IAAIhD,KAAKL,KAAKiB,aAAamC,QAE1Bb,EAAKe,SAASD,EAAQE,OAAShB,EAAKiB,YAAYH,EAAQE,MAClDF,EAAQE,KACRF,EAAQE,KAAKE,SACjBJ,EAAQK,SACTL,EAAQM,uBACON,EAAQO,mDAQ9BC,KACWC,iBClCAC,6HAA0Bb,wDASX3B,IAAxBlB,KAAKL,KAAKmC,gBAC4BZ,IAAtClB,KAAKL,KAAKmC,UAAU6B,sDAQZC,OACNC,EAAMD,EAAKxB,WAAW0B,MAAM,yCACZ,IAARD,GAA+B,OAARA,GAAgBA,EAAIzD,OAAS,EAC5DyD,EAAI,GACJ,oCAYNE,EACAhB,EACAC,EACAW,EACAK,mBAGKrE,KAAKmC,UAAU6B,cAAcM,SAASN,QAEtChE,KAAKmC,UAAU6B,cAAcO,MAC7B/C,KAAK,gBAEEgD,MACIJ,OACEf,EAAQoB,YACNC,SAASC,SAASC,aACjBrC,EAAKsC,WAAWxB,EAAQyB,SAC3B9D,EAAK+D,gBAAgB1B,EAAQyB,SAC7B,WACGvC,EAAKsC,WAAWxB,EAAQ2B,SAC3BhE,EAAK+D,gBAAgB1B,EAAQ2B,SAC7B,SAIWzD,IAAjB8B,EAAQ4B,MAAuC,OAAjB5B,EAAQ4B,OACtCT,EAAYU,OAAOC,OAAOX,EAAWnB,EAAQ4B,SAI5CG,iBAAiBhC,QACRC,EAAQE,UACRF,EAAQK,aACLL,EAAQgC,YACZhC,EAAQM,SACPa,qBACcnB,EAAQO,0BACpBP,EAAQiC,SAEnB9D,KAAK,aACW+D,mBAAmB/D,KAAK,cAEpBgE,OAAOC,YAAY,MAGvBC,OAGhBjE,MAAM,SAASkE,SACN,IAAIC,MACNC,EAASC,OAAOC,sBACZJ,EAAMK,aAIzBvE,MAAM,SAASkE,SACN,IAAIC,MACNC,EAASC,OAAOG,sBAAwBN,EAAMK,qDC5F7CE,6HAA2BhD,wDAQO3B,IAAxClB,KAAKL,KAAKmC,UAAUC,+CASxBgB,EAAeC,OACdQ,EAAexD,KAAKL,KAAKmC,UAAUC,gBAAgB+D,mBACnD/C,EACAC,EAAQK,KACRL,EAAQE,eAGC6C,OAENvC,WC1BMwC,6HAAgBnD,wDASF3B,IAAvBlB,KAAKL,KAAKqC,eAC0Bd,IAApClB,KAAKL,KAAKqC,SAASC,4CAUpBc,EAAeC,eAEbrD,KAAKqC,SAASiE,kCAEdtG,KAAKqC,SAASkE,yBACfhE,EAAKe,SAASD,EAAQE,OAAShB,EAAKiB,YAAYH,EAAQE,MAClDF,EAAQE,KACRF,EAAQE,KAAKiD,IACnBpD,QAGCpD,KAAKqC,SAASoE,qBAEZ,0CAQFzG,KAAKqC,SAASiE,sCC1CNI,6HAAoBxD,wDAQQ3B,IAAlClB,KAAKL,KAAKmB,mDASdiC,EAAeC,OACdQ,EAAexD,KAAKL,KAAKmB,oBAAoBgF,mBAC7C9C,EAAQE,KACRH,EACAC,EAAQK,eAGC0C,OAENvC,gCAOLA,KACW8C,yBCtCN,0BC8BC5G,kBAIH6G,WAAa,OAGbC,uBAGA7G,KAAOD,OAGPD,WAAa,IAAIA,EAAWC,QAG5B+G,iBACQ,IAAI3D,EAAapD,UAClB,IAAIgE,EAAkBhE,WACrB,IAAImG,EAAmBnG,MAC5B,IAAIsG,EAAQtG,UACR,IAAI2G,EAAY3G,SAGvBgH,8BACc,iCACL,SAASC,2DAUR5C,OACX6C,GAAU,EACRpD,EAAexD,KAAKwG,eAAezC,WAEpB7C,IAAjBsC,EAA4B,MAClBxD,KAAK6G,oBAAoB9C,GAG/B/D,KAAKyG,QAAQK,QAAQC,cACrB/G,KAAKyG,QAAQK,QAAQrD,MAAMD,QAC1B,GAAIxD,KAAKyG,QAAQO,OAAOD,mBAEpBN,QAAQO,OAAOvD,MAAMD,OACzB,CAAA,IAAIxD,KAAKyG,QAAQQ,GAAGF,uBAIX,EACJ,IAAIxB,MAAMC,EAASC,OAAOyB,wBAH3BT,QAAQQ,GAAGxD,eAMbmD,SAGJ,2CASMpD,OACPO,EAAK/D,KAAKuG,uBACXC,eAAezC,GAAMP,OACrB+C,aACExC,8CASSA,OACZ6C,GAAU,SAEV5G,KAAKwG,eAAe9D,eAAeqB,YAE5B/D,KAAKwG,eAAezC,MACjB,GAGP6C,+CAWU7C,EAAYf,OACzBmE,uBAIK,kBACMxG,EAAK6F,eAAezC,UAGxB,aACEqD,mBAAmBrD,KAK5Bf,EAAQqE,oBACG,aACC5D,SACTT,EAAQqE,SAGRF,iDASP9B,EACArC,EACAvC,cAEIsD,EAAK/D,KAAKsH,iBAAiBjC,EAAcA,EAAcjF,OAAS,IAGhE0B,WAAaA,UAAU6B,0BACbA,cAAc4D,iBAAiB,UAAW,gBAC1C3C,EAAO4C,KAAKC,MAAMC,EAAM9C,MAEV,UAAhBA,EAAK+C,QAAsBC,OAAOC,UAAUjD,EAAKb,KACjDnC,EAAKiF,oBAAoBjC,EAAKb,QAG9B/D,KAAK8H,qBAAqB/D,EAAIf,OAGlC,8CASRD,EACAC,EACAvC,OAGIkE,SADAnB,EAAe,UAITR,QAGA,cAED6D,oBAAoB9C,GACrB7B,EAAKsC,WAAWxB,EAAQ2B,YAChBA,QAAQtC,KAAK0F,EAAMvE,IAK/BxD,KAAKyG,QAAQK,QAAQC,oBAGF/G,KAAKyG,QAAQK,QAAQkB,OAAOjF,EAAOC,GACpD,MAAOiF,OACClE,EAAK/D,KAAKuG,WACV2B,EAAKlI,KAAKmI,SAASxE,cAQrB3D,KAAKyG,QAAQ2B,OAAOrB,oBACfN,QAAQ2B,OAAOJ,OAAOjE,EAAIhB,EAAOC,EAASkF,EARxC,mBACPH,EAAKM,uBACDhD,EACArC,EACAvC,UAQLT,KAAKyG,QAAQO,OAAOD,cAC3BvD,EAAexD,KAAKyG,QAAQO,OAAOgB,OAAOjF,EAAOC,GAC5ChD,KAAKyG,QAAQ6B,QAAQvB,mBAErBN,QAAQ6B,QAAQN,OAAOjF,EAAOC,GAC9BhD,KAAKyG,QAAQQ,GAAGF,gBAEN/G,KAAKyG,QAAQQ,GAAGe,OAAOjF,EAAOC,MAGrCD,MAAQA,OACXoF,SAASI,SAASvF,OAGN,OAAjBQ,EAAuB,KACjBO,EAAK/D,KAAKsH,iBAAiB9D,GAC3B2D,EAAUnH,KAAK8H,qBAAqB/D,EAAIf,GAG1Cd,EAAKsC,WAAWxB,EAAQwF,SACxBhF,EAAa+D,iBAAiB,OAAQvE,EAAQwF,QAE9CtG,EAAKsC,WAAWxB,EAAQyF,UACxBjF,EAAa+D,iBAAiB,QAASvE,EAAQyF,SAE/CvG,EAAKsC,WAAWxB,EAAQyB,UACxBjB,EAAa+D,iBAAiB,QAASvE,EAAQyB,WAEtC8C,iBAAiB,QAAS,aAC3BxD,OAGCwD,iBAAiB,SAAU,aAC5BxD,OAIJoD,KAIJ,qCAQLpE,EAAeC,OACd0F,aAGCxG,EAAKe,SAASF,SACT,IAAIwC,MAAMC,EAASC,OAAOkD,wBAI/B3I,KAAKP,WAAWmJ,MAYC,SAACnI,EAAqBoI,SAE3BC,gBAAgB/F,EAAOC,EAASvC,GACvC,MAAOwH,KACEA,KAfG,SAACxH,EAAqBoI,KAC/BpJ,WACAsJ,UACA5H,KAAK,aACG2H,gBAAgB/F,EAAOC,EAASvC,KAExCW,MAAM,aACIoE,EAASC,OAAOuD,sBAahC,IAAIxH,QAAQkH,uCASfjG,EADAwG,EAAQ,MAGPxG,KAAOzC,KAAKwG,eACTxG,KAAKwG,eAAe9D,eAAeD,IAAMwG,WAE1CA,gCAQL3F,OACEb,MAECA,KAAOzC,KAAKwG,kBACTxG,KAAKwG,eAAe9D,eAAeD,IACpBzC,KAAKwG,eAAe/D,GAGlBa,MAAQA,SAEdtD,KAAKoH,mBAAmB3E,uCAWvCA,EACAmE,GAAU,MAETnE,KAAOzC,KAAKwG,eACTxG,KAAKwG,eAAe9D,eAAeD,KACnCmE,EAAUA,GAAW5G,KAAKoH,mBAAmB3E,WAE9CmE,0CAQHsC,GAAY,MAEX,IAAIC,KAASnJ,KAAKyG,QACfzG,KAAKyG,QAAQ/D,eAAeyG,KAC5BD,EAAYA,GAAalJ,KAAKyG,QAAQ0C,GAAOpC,sBAE9CmC,iCAOJE,eAEqB,IAAbA,GACO,OAAbA,GAAqBlH,EAAKS,SAASyG,KAEpClH,EAAKU,YAAY5C,KAAK0G,eAAgB0C,GAEnCpJ,KAAK0G,8CAOT2C,OACCC,EAEAC,KAAa7G,mBAEZ6G,EAAQlH,KAAKgH,EAAU,gBAClB,IAAI9D,MAAMC,EAASC,OAAO+D,oBAa3B,IAAIC,KAVLF,EAAQlH,KAAKgH,EAAU,WACvBnH,EAAKS,SAAS0G,EAASlB,SACH,OAApBkB,EAASlB,aAEJA,OAAOkB,EAASlB,UAIhB,MADAkB,EAASC,QACEtJ,KAAKmI,UAIjBoB,EAAQlH,KAAKiH,EAAQG,IACrBvH,EAAKsC,WAAW8E,EAAOG,WAGlBA,GAAUH,EAAOG,aDja3B,CAA2B,oBAAXC,OAAyBA,OAASC"}